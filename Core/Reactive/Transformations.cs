using System;
using System.Collections.Generic;
using System.Text;

namespace Core.Reactive
{
    /// <summary>
    /// Transformations for a LiveData class.
    /// 
    /// You can use transformation methods to carry information 
    /// across the observer's lifecycle. 
    /// The transformations aren't calculated 
    /// unless an observer is observing the returned LiveData object.
    /// 
    /// Because the transformations are calculated lazily, 
    /// lifecycle-related behavior is implicitly passed down 
    /// without requiring additional explicit calls or dependencies.
    /// 
    /// Inspired by Android
    /// </summary>
    /// <seealso cref="https://developer.android.com/reference/android/arch/lifecycle/Transformations"/>
    public static class Transformations
    {
        /// <summary>
        /// Applies the given function on the main thread to each value emitted by source LiveData 
        /// and returns LiveData, which emits resulting values.
        /// 
        /// The given function func will be executed on the main thread.
        /// 
        /// Suppose that you have a LiveData, named userLiveData, that contains user data
        /// and you need to display the user name, created by concatenating the first and the last name of the user.
        /// You can define a function that handles the name creation,
        /// that will be applied to every value emitted by useLiveData.
        /// </summary>
        /// <typeparam name="TIn">source LiveData type</typeparam>
        /// <typeparam name="TOut">returned LiveData type</typeparam>
        /// <param name="source"> a LiveData to listen to</param>
        /// <param name="map">a function to apply</param>
        /// <returns>a LiveData which emits resulting values</returns>
        /// <seealso cref="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#map"/>
        public static LiveData<TOut> Map<TIn, TOut>(
            LiveData<TIn> source,
            Func<TIn, TOut> map
            ) => new MapLiveData<TIn, TOut>(source, map);

        /// <summary>
        /// Converts a .NET event, conforming to the standard .NET event pattern based on
        /// <see cref="System.EventHandler{TEventArgs}"/>, to an <see cref="LiveData{TEventArgs}"/>. 
        /// Each event invocation is surfaced through an <see cref="LiveData{TEventArgs}.PropertyChanged"/> invocation.
        /// 
        /// For conversion of events
        /// that don't conform to the standard .NET event pattern, use any of the FromEvent 
        /// overloads instead.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="addHandler">Action that attaches the given event handler to the underlying .NET event.</param>
        /// <param name="removeHandler">Action that detaches the given event handler from the underlying .NET event.</param>
        /// <returns>The Livedata that contains data representations of invocations of the underlying .NET event.</returns>
        /// <remarks>
        /// The current System.Threading.SynchronizationContext is captured during the call
        /// to FromEventPattern, and is used to post add and remove handler invocations.
        /// This behavior ensures add and remove handler operations for thread-affine events
        /// are accessed from the same context, as required by some UI frameworks.
        /// If no SynchronizationContext is present at the point of calling FromEventPattern,
        /// add and remove handler invocations are made synchronously on the thread making
        /// the Subscribe or Dispose call, respectively.
        /// </remarks>
        public static LiveData<TEventArgs> FromEventPattern<TEventArgs>(
            Action<EventHandler<TEventArgs>> addHandler,
            Action<EventHandler<TEventArgs>> removeHandler
            ) => new EventHandlerLiveData<TEventArgs>(addHandler, removeHandler);
    }
}
